format_version: 4
default_step_lib_source: https://github.com/bitrise-io/bitrise-steplib.git

app:
  envs:
  # An example secret param, define it (A_SECRET_PARAM) in .bitrise.secrets.yml
  - A_SECRET_PARAM: $A_SECRET_PARAM
  # If you want to share this step into a StepLib
  - BITRISE_STEP_ID: github-apps-installation-token
  - BITRISE_STEP_VERSION: "0.0.1"
  - BITRISE_STEP_GIT_CLONE_URL: https://github.com/Nikkei/bitrise-step-github-apps-installation-token.git
  - MY_STEPLIB_REPO_FORK_GIT_URL: $MY_STEPLIB_REPO_FORK_GIT_URL

workflows:
  test:
    title: Test with valid credentials
    description: |-
      Tests the step with valid GitHub App credentials.
      Requires .bitrise.secrets.yml with GITHUB_APP_ID, GITHUB_INSTALLATION_ID, and GITHUB_APP_PRIVATE_PEM.
    steps:
    - change-workdir:
        title: Switch working dir to test / _tmp dir
        description: |-
          To prevent step testing issues, like referencing relative
          files with just './some-file' in the step's code, which would
          work for testing the step from this directory directly
          but would break if the step is included in another `bitrise.yml`.
        run_if: true
        inputs:
        - path: ./_tmp
        - is_create_path: true
    - path::./:
        title: Generate GitHub Apps Installation Token
        description: Test basic token generation with valid credentials
        run_if: true
        inputs:
        - app_id: $GITHUB_APP_ID
        - installation_id: $GITHUB_INSTALLATION_ID
        - private_pem: $GITHUB_APP_PRIVATE_PEM
    - script:
        title: Verify token was exported
        inputs:
        - content: |
            #!/bin/bash
            set -e
            if [ -z "$GITHUB_APPS_INSTALLATION_TOKEN" ]; then
              echo "ERROR: GITHUB_APPS_INSTALLATION_TOKEN was not exported"
              exit 1
            fi
            echo "SUCCESS: Token was exported (length: ${#GITHUB_APPS_INSTALLATION_TOKEN} characters)"
            # Verify token format (should start with ghs_)
            if [[ $GITHUB_APPS_INSTALLATION_TOKEN == ghs_* ]]; then
              echo "SUCCESS: Token has expected format (ghs_ prefix)"
            else
              echo "WARNING: Token does not have expected ghs_ prefix"
            fi

  test-permissions:
    title: Test with custom permissions
    description: |-
      Tests the step with custom permission scopes.
      Requires .bitrise.secrets.yml with GITHUB_APP_ID, GITHUB_INSTALLATION_ID, and GITHUB_APP_PRIVATE_PEM.
      Uses limited permissions to verify least-privilege functionality.
    steps:
    - change-workdir:
        title: Switch working dir to test / _tmp dir
        run_if: true
        inputs:
        - path: ./_tmp
        - is_create_path: true
    - path::./:
        title: Generate token with custom permissions
        description: Test token generation with restricted permissions (YAML hash format)
        run_if: true
        inputs:
        - app_id: $GITHUB_APP_ID
        - installation_id: $GITHUB_INSTALLATION_ID
        - private_pem: $GITHUB_APP_PRIVATE_PEM
        - permissions:
            contents: read
            metadata: read
    - script:
        title: Verify token and check permissions
        inputs:
        - content: |
            #!/bin/bash
            set -e

            # Verify token was exported
            if [ -z "$GITHUB_APPS_INSTALLATION_TOKEN" ]; then
              echo "ERROR: GITHUB_APPS_INSTALLATION_TOKEN was not exported"
              exit 1
            fi
            echo "SUCCESS: Token was exported with custom permissions"

            # Try to query the token's permissions via GitHub API
            # This requires the token to be valid and the app to have API access
            echo "Verifying token permissions..."
            response=$(curl -s -H "Authorization: Bearer $GITHUB_APPS_INSTALLATION_TOKEN" \
                           -H "Accept: application/vnd.github+json" \
                           -H "X-GitHub-Api-Version: 2022-11-28" \
                           https://api.github.com/installation/repositories 2>&1 || echo "API call failed")

            if echo "$response" | grep -q "API call failed"; then
              echo "NOTE: Could not verify permissions via API (may require valid installation)"
              echo "Token generation with custom permissions succeeded"
            elif echo "$response" | grep -q "total_count"; then
              echo "SUCCESS: Token is valid and has access to repositories"
              echo "Permissions verification complete"
            else
              echo "WARNING: Unexpected API response, but token was generated"
            fi

  test-error-missing-app-id:
    title: Test error handling - missing app_id
    description: Verify clear error message when app_id is not provided
    steps:
    - change-workdir:
        run_if: true
        inputs:
        - path: ./_tmp
        - is_create_path: true
    - path::./:
        is_skippable: true
        inputs:
        - app_id: ""
        - installation_id: "123456"
        - private_pem: "fake-pem"
    - script:
        inputs:
        - content: |
            #!/bin/bash
            # This should not run - previous step should fail
            echo "ERROR: Step should have failed with missing app_id"
            exit 1

  test-error-invalid-app-id:
    title: Test error handling - non-numeric app_id
    description: Verify clear error message when app_id is not numeric
    steps:
    - change-workdir:
        run_if: true
        inputs:
        - path: ./_tmp
        - is_create_path: true
    - path::./:
        is_skippable: true
        inputs:
        - app_id: "not-a-number"
        - installation_id: "123456"
        - private_pem: "fake-pem"
    - script:
        inputs:
        - content: |
            #!/bin/bash
            echo "ERROR: Step should have failed with non-numeric app_id"
            exit 1

  test-error-missing-installation-id:
    title: Test error handling - missing installation_id
    description: Verify clear error message when installation_id is not provided
    steps:
    - change-workdir:
        run_if: true
        inputs:
        - path: ./_tmp
        - is_create_path: true
    - path::./:
        is_skippable: true
        inputs:
        - app_id: "123456"
        - installation_id: ""
        - private_pem: "fake-pem"
    - script:
        inputs:
        - content: |
            #!/bin/bash
            echo "ERROR: Step should have failed with missing installation_id"
            exit 1

  test-error-invalid-pem:
    title: Test error handling - invalid PEM format
    description: Verify clear error message when PEM is missing BEGIN/END markers
    steps:
    - change-workdir:
        run_if: true
        inputs:
        - path: ./_tmp
        - is_create_path: true
    - path::./:
        is_skippable: true
        inputs:
        - app_id: "123456"
        - installation_id: "789012"
        - private_pem: "this-is-not-a-valid-pem-key"
    - script:
        inputs:
        - content: |
            #!/bin/bash
            echo "ERROR: Step should have failed with invalid PEM format"
            exit 1

  test-error-invalid-permissions-json:
    title: Test error handling - invalid permissions JSON
    description: Verify clear error message when permissions is not valid JSON
    steps:
    - change-workdir:
        run_if: true
        inputs:
        - path: ./_tmp
        - is_create_path: true
    - path::./:
        is_skippable: true
        inputs:
        - app_id: "123456"
        - installation_id: "789012"
        - private_pem: |
            -----BEGIN RSA PRIVATE KEY-----
            fake-key-content
            -----END RSA PRIVATE KEY-----
        - permissions: 'not-valid-json{bad'
    - script:
        inputs:
        - content: |
            #!/bin/bash
            echo "ERROR: Step should have failed with invalid JSON permissions"
            exit 1

  # ----------------------------------------------------------------
  # --- workflows to Share this step into a Step Library
  audit-this-step:
    steps:
    - script:
        inputs:
        - content: |-
            #!/bin/bash
            set -ex
            stepman audit --step-yml ./step.yml

  share-this-step:
    envs:
      # if you want to share this step into a StepLib
      - MY_STEPLIB_REPO_FORK_GIT_URL: $MY_STEPLIB_REPO_FORK_GIT_URL
      - BITRISE_STEP_ID: $BITRISE_STEP_ID
      - BITRISE_STEP_VERSION: $BITRISE_STEP_VERSION
      - BITRISE_STEP_GIT_CLONE_URL: $BITRISE_STEP_GIT_CLONE_URL
    description: |-
      If this is the first time you try to share a Step you should
      first call: $ bitrise share

      This will print you a guide, and information about how Step sharing
      works. Please read it at least once!

      As noted in the Step sharing guide you'll have to fork the
      StepLib you want to share this step into. Once you're done with forking
      the repository you should set your own fork's git clone URL
      in the `.bitrise.secrets.yml` file, or here in the `envs` section,
      as the value of the `MY_STEPLIB_REPO_FORK_GIT_URL` environment.

      You're now ready to share this Step, just make sure that
      the `BITRISE_STEP_ID` and `BITRISE_STEP_VERSION`
      environments are set to the desired values!

      To share this Step into a StepLib you can just run: $ bitrise run share-this-step

      Once it finishes the only thing left is to actually create a Pull Request,
      the way described in the guide printed at the end of the process.
    before_run:
    - audit-this-step
    steps:
    - script:
        inputs:
        - content: |-
            #!/bin/bash
            set -ex
            bitrise share start -c "${MY_STEPLIB_REPO_FORK_GIT_URL}"
            bitrise share create --stepid "${BITRISE_STEP_ID}" --tag "${BITRISE_STEP_VERSION}" --git "${BITRISE_STEP_GIT_CLONE_URL}"
            bitrise share finish
